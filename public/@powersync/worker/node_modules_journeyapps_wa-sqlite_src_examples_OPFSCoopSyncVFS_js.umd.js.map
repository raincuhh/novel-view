{"version":3,"file":"worker/node_modules_journeyapps_wa-sqlite_src_examples_OPFSCoopSyncVFS_js.umd.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACliBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sdk_web/./node_modules/@journeyapps/wa-sqlite/src/FacadeVFS.js","webpack://sdk_web/./node_modules/@journeyapps/wa-sqlite/src/VFS.js","webpack://sdk_web/./node_modules/@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js"],"sourcesContent":["// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './VFS.js';\n\nconst AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\n// Milliseconds since Julian epoch as a BigInt.\n// https://github.com/sqlite/sqlite/blob/e57527c14f7b7cfa6e32eeab5c549d50c4fa3674/src/os_unix.c#L6872-L6882\nconst UNIX_EPOCH = 24405875n * 8640000n;\n\n// Convenience base class for a JavaScript VFS.\n// The raw xOpen, xRead, etc. function signatures receive only C primitives\n// which aren't easy to work with. This class provides corresponding calls\n// like jOpen, jRead, etc., which receive JavaScript-friendlier arguments\n// such as string, Uint8Array, and DataView.\nexport class FacadeVFS extends VFS.Base {\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    super(name, module);\n  }\n\n  /**\n   * Override to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    // The input argument is a string like \"xOpen\", so convert to \"jOpen\".\n    // Then check if the method exists and is async.\n    const jMethodName = `j${methodName.slice(1)}`;\n    return this[jMethodName] instanceof AsyncFunction;\n  }\n  \n  /**\n   * Return the filename for a file id for use by mixins.\n   * @param {number} pFile \n   * @returns {string}\n   */\n  getFilename(pFile) {\n    throw new Error('unimplemented');\n  }\n\n  /**\n   * @param {string?} filename \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  jOpen(filename, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  jDelete(filename, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jAccess(filename, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {string} filename \n   * @param {Uint8Array} zOut \n   * @returns {number|Promise<number>}\n   */\n  jFullPathname(filename, zOut) {\n    // Copy the filename to the output buffer.\n    const { read, written } = new TextEncoder().encodeInto(filename, zOut);\n    if (read < filename.length) return VFS.SQLITE_IOERR;\n    if (written >= zOut.length) return VFS.SQLITE_IOERR;\n    zOut[written] = 0;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns {number|Promise<number>}\n   */\n  jGetLastError(zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  jClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jRead(pFile, pData, iOffset) {\n    pData.fill(0);\n    return VFS.SQLITE_IOERR_SHORT_READ;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {Uint8Array} pData \n   * @param {number} iOffset \n   * @returns {number|Promise<number>}\n   */\n  jWrite(pFile, pData, iOffset) {\n    return VFS.SQLITE_IOERR_WRITE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} size \n   * @returns {number|Promise<number>}\n   */\n  jTruncate(pFile, size) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  jSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pSize\n   * @returns {number|Promise<number>}\n   */\n  jFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  jUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {DataView} pResOut \n   * @returns {number|Promise<number>}\n   */\n  jCheckReservedLock(pFile, pResOut) {\n    pResOut.setInt32(0, 0, true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jSectorSize(pFile) {\n    return super.xSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile\n   * @returns {number|Promise<number>}\n   */\n  jDeviceCharacteristics(pFile) {\n    return 0;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    const filename = this.#decodeFilename(zName, flags);\n    const pOutFlagsView = this.#makeTypedDataView('Int32', pOutFlags);\n    this['log']?.('jOpen', filename, pFile, '0x' + flags.toString(16));\n    return this.jOpen(filename, pFile, flags, pOutFlagsView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nByte \n   * @param {number} pCharOut\n   * @returns {number|Promise<number>}\n   */\n  xRandomness(pVfs, nByte, pCharOut) {\n    const randomArray = new Uint8Array(nByte);\n    crypto.getRandomValues(randomArray);\n    // Copy randomArray to the WebAssembly memory\n    const buffer = pCharOut; // Pointer to memory in WebAssembly\n    this._module.HEAPU8.set(randomArray, buffer); // Copy randomArray into memory starting at buffer\n    return nByte;\n  }\n\n  /**\n   * Gets the current time as milliseconds since Unix epoch\n   * @param {number} pVfs pointer to the VFS\n   * @param {number} pTime pointer to write the time value\n   * @returns {number} SQLite error code\n   */\n  xCurrentTimeInt64(pVfs, pTime) {\n    // Create a DataView to write the current time\n    const timeView = this.#makeTypedDataView('BigInt64', pTime);\n  \n    const currentTime = BigInt(Date.now());\n    // Convert the current time to milliseconds since Unix epoch\n    const value = UNIX_EPOCH + currentTime;\n    \n    // Write the time value to the pointer location\n    timeView.setBigInt64(0, value, true);\n    \n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    const filename = this._module.UTF8ToString(zName);\n    this['log']?.('jDelete', filename, syncDir);\n    return this.jDelete(filename, syncDir);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jAccess', filename, flags);\n    return this.jAccess(filename, flags, pResOutView);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    const filename = this._module.UTF8ToString(zName);\n    const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);\n    this['log']?.('jFullPathname', filename, nOut);\n    return this.jFullPathname(filename, zOutArray);\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);\n    this['log']?.('jGetLastError', nBuf);\n    return this.jGetLastError(zBufArray);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    this['log']?.('jClose', pFile);\n    return this.jClose(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jRead', pFile, iAmt, iOffset);\n    return this.jRead(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    const pDataArray = this.#makeDataArray(pData, iAmt);\n    const iOffset = delegalize(iOffsetLo, iOffsetHi);\n    this['log']?.('jWrite', pFile, pDataArray, iOffset);\n    return this.jWrite(pFile, pDataArray, iOffset);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    const size = delegalize(sizeLo, sizeHi);\n    this['log']?.('jTruncate', pFile, size);\n    return this.jTruncate(pFile, size);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    this['log']?.('jSync', pFile, flags);\n    return this.jSync(pFile, flags);\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    const pSizeView = this.#makeTypedDataView('BigInt64', pSize);\n    this['log']?.('jFileSize', pFile);\n    return this.jFileSize(pFile, pSizeView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    this['log']?.('jLock', pFile, lockType);\n    return this.jLock(pFile, lockType);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    this['log']?.('jUnlock', pFile, lockType);\n    return this.jUnlock(pFile, lockType);\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    const pResOutView = this.#makeTypedDataView('Int32', pResOut);\n    this['log']?.('jCheckReservedLock', pFile);\n    return this.jCheckReservedLock(pFile, pResOutView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    const pArgView = new DataView(\n      this._module.HEAPU8.buffer,\n      this._module.HEAPU8.byteOffset + pArg);\n    this['log']?.('jFileControl', pFile, op, pArgView);\n    return this.jFileControl(pFile, op, pArgView);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    this['log']?.('jSectorSize', pFile);\n    return this.jSectorSize(pFile);\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    this['log']?.('jDeviceCharacteristics', pFile);\n    return this.jDeviceCharacteristics(pFile);\n  }\n\n  /**\n   * Wrapped DataView for pointer arguments.\n   * Pointers to a single value are passed using DataView. A Proxy\n   * wrapper prevents use of incorrect type or endianness.\n   * @param {'Int32'|'BigInt64'} type \n   * @param {number} byteOffset \n   * @returns {DataView}\n   */\n  #makeTypedDataView(type, byteOffset) {\n    const byteLength = type === 'Int32' ? 4 : 8;\n    const getter = `get${type}`;\n    const setter = `set${type}`;\n    const makeDataView = () => new DataView(\n      this._module.HEAPU8.buffer,\n      this._module.HEAPU8.byteOffset + byteOffset,\n      byteLength);\n    let dataView = makeDataView();\n    return new Proxy(dataView, {\n      get(_, prop) {\n        if (dataView.buffer.byteLength === 0) {\n          // WebAssembly memory resize detached the buffer.\n          dataView = makeDataView();\n        }\n        if (prop === getter) {\n          return function(byteOffset, littleEndian) {\n            if (!littleEndian) throw new Error('must be little endian');\n            return dataView[prop](byteOffset, littleEndian);\n          }\n        }\n        if (prop === setter) {\n          return function(byteOffset, value, littleEndian) {\n            if (!littleEndian) throw new Error('must be little endian');\n            return dataView[prop](byteOffset, value, littleEndian);\n          }\n        }\n        if (typeof prop === 'string' && (prop.match(/^(get)|(set)/))) {\n          throw new Error('invalid type');\n        }\n        const result = dataView[prop];\n        return typeof result === 'function' ? result.bind(dataView) : result;\n      }\n    });\n  }\n\n  /**\n   * @param {number} byteOffset \n   * @param {number} byteLength \n   */\n  #makeDataArray(byteOffset, byteLength) {\n    let target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);\n    return new Proxy(target, {\n      get: (_, prop, receiver) => {\n        if (target.buffer.byteLength === 0) {\n          // WebAssembly memory resize detached the buffer.\n          target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);\n        }\n        const result = target[prop];\n        return typeof result === 'function' ? result.bind(target) : result;\n      }\n    });\n  }\n\n  #decodeFilename(zName, flags) {\n    if (flags & VFS.SQLITE_OPEN_URI) {\n      // The first null-terminated string is the URI path. Subsequent\n      // strings are query parameter keys and values.\n      // https://www.sqlite.org/c3ref/open.html#urifilenamesinsqlite3open\n      let pName = zName;\n      let state = 1;\n      const charCodes = [];\n      while (state) {\n        const charCode = this._module.HEAPU8[pName++];\n        if (charCode) {\n          charCodes.push(charCode);\n        } else {\n          if (!this._module.HEAPU8[pName]) state = null;\n          switch (state) {\n            case 1: // path\n              charCodes.push('?'.charCodeAt(0));\n              state = 2;\n              break;\n            case 2: // key\n              charCodes.push('='.charCodeAt(0));\n              state = 3;\n              break;\n            case 3: // value\n              charCodes.push('&'.charCodeAt(0));\n              state = 2;\n              break;\n          }\n        }\n      }\n      return  new TextDecoder().decode(new Uint8Array(charCodes));\n    }\n    return zName ? this._module.UTF8ToString(zName) : null;\n  }\n}\n\n// Emscripten \"legalizes\" 64-bit integer arguments by passing them as\n// two 32-bit signed integers.\nfunction delegalize(lo32, hi32) {\n  return (hi32 * 0x100000000) + lo32 + (lo32 < 0 ? 2**32 : 0);\n}\n","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from './sqlite-constants.js';\nexport * from './sqlite-constants.js';\n\nconst DEFAULT_SECTOR_SIZE = 512;\n\n// Base class for a VFS.\nexport class Base {\n  name;\n  mxPathname = 64;\n  _module;\n\n  /**\n   * @param {string} name \n   * @param {object} module \n   */\n  constructor(name, module) {\n    this.name = name;\n    this._module = module;\n  }\n\n  /**\n   * @returns {void|Promise<void>} \n   */\n  close() {\n  }\n\n  /**\n   * @returns {boolean|Promise<boolean>}\n   */\n  isReady() {\n    return true;\n  }\n\n  /**\n   * Overload in subclasses to indicate which methods are asynchronous.\n   * @param {string} methodName \n   * @returns {boolean}\n   */\n  hasAsyncMethod(methodName) {\n    return false;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} pFile \n   * @param {number} flags \n   * @param {number} pOutFlags \n   * @returns {number|Promise<number>}\n   */\n  xOpen(pVfs, zName, pFile, flags, pOutFlags) {\n    return VFS.SQLITE_CANTOPEN;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} syncDir \n   * @returns {number|Promise<number>}\n   */\n  xDelete(pVfs, zName, syncDir) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} flags \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xAccess(pVfs, zName, flags, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} zName \n   * @param {number} nOut \n   * @param {number} zOut \n   * @returns {number|Promise<number>}\n   */\n  xFullPathname(pVfs, zName, nOut, zOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pVfs \n   * @param {number} nBuf \n   * @param {number} zBuf \n   * @returns {number|Promise<number>}\n   */\n  xGetLastError(pVfs, nBuf, zBuf) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xClose(pFile) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} pData \n   * @param {number} iAmt \n   * @param {number} iOffsetLo \n   * @param {number} iOffsetHi \n   * @returns {number|Promise<number>}\n   */\n  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} sizeLo \n   * @param {number} sizeHi \n   * @returns {number|Promise<number>}\n   */\n  xTruncate(pFile, sizeLo, sizeHi) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} flags \n   * @returns {number|Promise<number>}\n   */\n  xSync(pFile, flags) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * \n   * @param {number} pFile \n   * @param {number} pSize \n   * @returns {number|Promise<number>}\n   */\n  xFileSize(pFile, pSize) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xLock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} lockType \n   * @returns {number|Promise<number>}\n   */\n  xUnlock(pFile, lockType) {\n    return VFS.SQLITE_OK;\n  } \n\n  /**\n   * @param {number} pFile \n   * @param {number} pResOut \n   * @returns {number|Promise<number>}\n   */\n  xCheckReservedLock(pFile, pResOut) {\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} pFile \n   * @param {number} op \n   * @param {number} pArg \n   * @returns {number|Promise<number>}\n   */\n  xFileControl(pFile, op, pArg) {\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xSectorSize(pFile) {\n    return DEFAULT_SECTOR_SIZE;\n  }\n\n  /**\n   * @param {number} pFile \n   * @returns {number|Promise<number>}\n   */\n  xDeviceCharacteristics(pFile) {\n    return 0;\n  }\n}\n\nexport const FILE_TYPE_MASK = [\n  VFS.SQLITE_OPEN_MAIN_DB,\n  VFS.SQLITE_OPEN_MAIN_JOURNAL,\n  VFS.SQLITE_OPEN_TEMP_DB,\n  VFS.SQLITE_OPEN_TEMP_JOURNAL,\n  VFS.SQLITE_OPEN_TRANSIENT_DB,\n  VFS.SQLITE_OPEN_SUBJOURNAL,\n  VFS.SQLITE_OPEN_SUPER_JOURNAL,\n  VFS.SQLITE_OPEN_WAL\n].reduce((mask, element) => mask | element);","// Copyright 2024 Roy T. Hashimoto. All Rights Reserved.\nimport { FacadeVFS } from '../FacadeVFS.js';\nimport * as VFS from '../VFS.js';\n\nconst DEFAULT_TEMPORARY_FILES = 10;\nconst LOCK_NOTIFY_INTERVAL = 1000;\n\nconst DB_RELATED_FILE_SUFFIXES = ['', '-journal', '-wal'];\n\nconst finalizationRegistry = new FinalizationRegistry(releaser => releaser());\n\nclass File {\n  /** @type {string} */ path\n  /** @type {number} */ flags;\n  /** @type {FileSystemSyncAccessHandle} */ accessHandle;\n\n  /** @type {PersistentFile?} */ persistentFile;\n\n  constructor(path, flags) {\n    this.path = path;\n    this.flags = flags;\n  }\n}\n\nclass PersistentFile {\n  /** @type {FileSystemFileHandle} */ fileHandle\n  /** @type {FileSystemSyncAccessHandle} */ accessHandle = null\n\n  // The following properties are for main database files.\n\n  /** @type {boolean} */ isLockBusy = false;\n  /** @type {boolean} */ isFileLocked = false;\n  /** @type {boolean} */ isRequestInProgress = false;\n  /** @type {function} */ handleLockReleaser = null;\n\n  /** @type {BroadcastChannel} */ handleRequestChannel;\n  /** @type {boolean} */ isHandleRequested = false;\n\n  constructor(fileHandle) {\n    this.fileHandle = fileHandle;\n  }\n}\n\nexport class OPFSCoopSyncVFS extends FacadeVFS {\n  /** @type {Map<number, File>} */ mapIdToFile = new Map();\n\n  lastError = null;\n  log = null; //function(...args) { console.log(`[${contextName}]`, ...args) };\n  \n  /** @type {Map<string, PersistentFile>} */ persistentFiles = new Map();\n  /** @type {Map<string, FileSystemSyncAccessHandle>} */ boundAccessHandles = new Map();\n  /** @type {Set<FileSystemSyncAccessHandle>} */ unboundAccessHandles = new Set();\n  /** @type {Set<string>} */ accessiblePaths = new Set();\n  releaser = null;\n\n  static async create(name, module) {\n    const vfs = new OPFSCoopSyncVFS(name, module);\n    await Promise.all([\n      vfs.isReady(),\n      vfs.#initialize(DEFAULT_TEMPORARY_FILES),\n    ]);\n    return vfs;\n  }\n\n  constructor(name, module) {\n    super(name, module);\n  }\n\n  async #initialize(nTemporaryFiles) {\n    // Delete temporary directories no longer in use.\n    const root = await navigator.storage.getDirectory();\n    // @ts-ignore\n    for await (const entry of root.values()) {\n      if (entry.kind === 'directory' && entry.name.startsWith('.ahp-')) {\n        // A lock with the same name as the directory protects it from\n        // being deleted.\n        await navigator.locks.request(entry.name, { ifAvailable: true }, async lock => {\n          if (lock) {\n            this.log?.(`Deleting temporary directory ${entry.name}`);\n            await root.removeEntry(entry.name, { recursive: true });\n          } else {\n            this.log?.(`Temporary directory ${entry.name} is in use`);\n          }\n        });\n      }\n    }\n\n    // Create our temporary directory.\n    const tmpDirName = `.ahp-${Math.random().toString(36).slice(2)}`;\n    this.releaser = await new Promise(resolve => {\n      navigator.locks.request(tmpDirName, () => {\n        return new Promise(release => {\n          resolve(release);\n        });\n      });\n    });\n    finalizationRegistry.register(this, this.releaser);\n    const tmpDir = await root.getDirectoryHandle(tmpDirName, { create: true });\n\n    // Populate temporary directory.\n    for (let i = 0; i < nTemporaryFiles; i++) {\n      const tmpFile = await tmpDir.getFileHandle(`${i}.tmp`, { create: true });\n      const tmpAccessHandle = await tmpFile.createSyncAccessHandle();\n      this.unboundAccessHandles.add(tmpAccessHandle);\n    }\n  }\n\n  /**\n   * @param {string?} zName \n   * @param {number} fileId \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number}\n   */\n  jOpen(zName, fileId, flags, pOutFlags) {\n    try {\n      const url = new URL(zName || Math.random().toString(36).slice(2), 'file://');\n      const path = url.pathname;\n\n      if (flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        const persistentFile = this.persistentFiles.get(path);\n        if (persistentFile?.isRequestInProgress) {\n          // Should not reach here unless SQLite itself retries an open.\n          // Otherwise, asynchronous operations started on a previous\n          // open try should have completed.\n          return VFS.SQLITE_BUSY;\n        } else if (!persistentFile) {\n          // This is the usual starting point for opening a database.\n          // Register a Promise that resolves when the database and related\n          // files are ready to be used.\n          this.log?.(`creating persistent file for ${path}`);\n          const create = !!(flags & VFS.SQLITE_OPEN_CREATE);\n          this._module.retryOps.push((async () => {\n            try {\n              // Get the path directory handle.\n              let dirHandle = await navigator.storage.getDirectory();\n              const directories = path.split('/').filter(d => d);\n              const filename = directories.pop();\n              for (const directory of directories) {\n                dirHandle = await dirHandle.getDirectoryHandle(directory, { create });\n              }\n\n              // Get file handles for the database and related files,\n              // and create persistent file instances.\n              for (const suffix of DB_RELATED_FILE_SUFFIXES) {\n                const fileHandle = await dirHandle.getFileHandle(filename + suffix, { create });\n                await this.#createPersistentFile(fileHandle);\n              }\n\n              // Get access handles for the files.\n              const file = new File(path, flags);\n              file.persistentFile = this.persistentFiles.get(path);\n              await this.#requestAccessHandle(file);\n            } catch (e) {\n              // Use an invalid persistent file to signal this error\n              // for the retried open.\n              const persistentFile = new PersistentFile(null);\n              this.persistentFiles.set(path, persistentFile);\n              console.error(e);\n            }\n          })());\n          return VFS.SQLITE_BUSY;\n        } else if (!persistentFile.fileHandle) {\n          // The asynchronous open operation failed.\n          this.persistentFiles.delete(path);\n          return VFS.SQLITE_CANTOPEN;\n        } else if (!persistentFile.accessHandle) {\n          // This branch is reached if the database was previously opened\n          // and closed.\n          this._module.retryOps.push((async () => {\n            const file = new File(path, flags);\n            file.persistentFile = this.persistentFiles.get(path);\n            await this.#requestAccessHandle(file);\n          })());\n          return VFS.SQLITE_BUSY;\n        }\n      }\n\n      if (!this.accessiblePaths.has(path) &&\n          !(flags & VFS.SQLITE_OPEN_CREATE)) {\n        throw new Error(`File ${path} not found`);\n      }\n\n      const file = new File(path, flags);\n      this.mapIdToFile.set(fileId, file);\n\n      if (this.persistentFiles.has(path)) {\n        file.persistentFile = this.persistentFiles.get(path);\n      } else if (this.boundAccessHandles.has(path)) {\n        // This temporary file was previously created and closed. Reopen\n        // the same access handle.\n        file.accessHandle = this.boundAccessHandles.get(path);\n      } else if (this.unboundAccessHandles.size) {\n        // Associate an unbound access handle to this file.\n        file.accessHandle = this.unboundAccessHandles.values().next().value;\n        file.accessHandle.truncate(0);\n        this.unboundAccessHandles.delete(file.accessHandle);\n        this.boundAccessHandles.set(path, file.accessHandle);\n      }\n      this.accessiblePaths.add(path);\n  \n      pOutFlags.setInt32(0, flags, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_CANTOPEN;\n    }\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} syncDir \n   * @returns {number}\n   */\n  jDelete(zName, syncDir) {\n    try {\n      const url = new URL(zName, 'file://');\n      const path = url.pathname;\n      if (this.persistentFiles.has(path)) {\n        const persistentFile = this.persistentFiles.get(path);\n        persistentFile.accessHandle.truncate(0);\n      } else {\n        this.boundAccessHandles.get(path)?.truncate(0);\n      }\n      this.accessiblePaths.delete(path);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_DELETE;\n    }\n  }\n\n  /**\n   * @param {string} zName \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  jAccess(zName, flags, pResOut) {\n    try {\n      const url = new URL(zName, 'file://');\n      const path = url.pathname;\n      pResOut.setInt32(0, this.accessiblePaths.has(path) ? 1 : 0, true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_ACCESS;\n    } \n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  jClose(fileId) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      this.mapIdToFile.delete(fileId);\n\n      if (file?.flags & VFS.SQLITE_OPEN_MAIN_DB) {\n        if (file.persistentFile?.handleLockReleaser) {\n          this.#releaseAccessHandle(file);\n        }\n      } else if (file?.flags & VFS.SQLITE_OPEN_DELETEONCLOSE) {\n        file.accessHandle.truncate(0);\n        this.accessiblePaths.delete(file.path);\n        if (!this.persistentFiles.has(file.path)) {\n          this.boundAccessHandles.delete(file.path);\n          this.unboundAccessHandles.add(file.accessHandle);\n        }\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_CLOSE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  jRead(fileId, pData, iOffset) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n\n      // On Chrome (at least), passing pData to accessHandle.read() is\n      // an error because pData is a Proxy of a Uint8Array. Calling\n      // subarray() produces a real Uint8Array and that works.\n      const accessHandle = file.accessHandle || file.persistentFile.accessHandle;\n      const bytesRead = accessHandle.read(pData.subarray(), { at: iOffset });\n\n      // Opening a database file performs one read without a xLock call.\n      if ((file.flags & VFS.SQLITE_OPEN_MAIN_DB) && !file.persistentFile.isFileLocked) {\n        this.#releaseAccessHandle(file);\n      }\n\n      if (bytesRead < pData.byteLength) {\n        pData.fill(0, bytesRead);\n        return VFS.SQLITE_IOERR_SHORT_READ;\n      }\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_READ;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  jWrite(fileId, pData, iOffset) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n\n      // On Chrome (at least), passing pData to accessHandle.write() is\n      // an error because pData is a Proxy of a Uint8Array. Calling\n      // subarray() produces a real Uint8Array and that works.\n      const accessHandle = file.accessHandle || file.persistentFile.accessHandle;\n      const nBytes = accessHandle.write(pData.subarray(), { at: iOffset });\n      if (nBytes !== pData.byteLength) throw new Error('short write');\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_WRITE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} iSize \n   * @returns {number}\n   */\n  jTruncate(fileId, iSize) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      const accessHandle = file.accessHandle || file.persistentFile.accessHandle;\n      accessHandle.truncate(iSize);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_TRUNCATE;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  jSync(fileId, flags) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      const accessHandle = file.accessHandle || file.persistentFile.accessHandle;\n      accessHandle.flush();\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_FSYNC;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pSize64 \n   * @returns {number}\n   */\n  jFileSize(fileId, pSize64) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      const accessHandle = file.accessHandle || file.persistentFile.accessHandle;\n      const size = accessHandle.getSize();\n      pSize64.setBigInt64(0, BigInt(size), true);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR_FSTAT;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {number}\n   */\n  jLock(fileId, lockType) {\n    const file = this.mapIdToFile.get(fileId);\n    if (file.persistentFile.isRequestInProgress) {\n      file.persistentFile.isLockBusy = true;\n      return VFS.SQLITE_BUSY;\n    }\n\n    file.persistentFile.isFileLocked = true;\n    if (!file.persistentFile.handleLockReleaser) {\n      // Start listening for notifications from other connections.\n      // This is before we actually get access handles, but waiting to\n      // listen until then allows a race condition where notifications\n      // are missed. \n      file.persistentFile.handleRequestChannel.onmessage = () => {\n        this.log?.(`received notification for ${file.path}`);\n        if (file.persistentFile.isFileLocked) {\n          // We're still using the access handle, so mark it to be\n          // released when we're done.\n          file.persistentFile.isHandleRequested = true;\n        } else {\n          // Release the access handles immediately.\n          this.#releaseAccessHandle(file);\n        }\n        file.persistentFile.handleRequestChannel.onmessage = null;\n      };\n\n      this.#requestAccessHandle(file);\n      this.log?.('returning SQLITE_BUSY');\n      file.persistentFile.isLockBusy = true;\n      return VFS.SQLITE_BUSY;\n    }\n    file.persistentFile.isLockBusy = false;\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} lockType \n   * @returns {number}\n   */\n  jUnlock(fileId, lockType) {\n    const file = this.mapIdToFile.get(fileId);\n    if (lockType === VFS.SQLITE_LOCK_NONE) {\n      // Don't change any state if this unlock is because xLock returned\n      // SQLITE_BUSY.\n      if (!file.persistentFile.isLockBusy) {\n        if (file.persistentFile.isHandleRequested) {\n            // Another connection wants the access handle.\n          this.#releaseAccessHandle(file);\n          this.isHandleRequested = false;\n        }\n        file.persistentFile.isFileLocked = false;\n      }\n    }\n    return VFS.SQLITE_OK;\n  }\n  \n  /**\n   * @param {number} fileId\n   * @param {number} op\n   * @param {DataView} pArg\n   * @returns {number|Promise<number>}\n   */\n  jFileControl(fileId, op, pArg) {\n    try {\n      const file = this.mapIdToFile.get(fileId);\n      switch (op) {\n        case VFS.SQLITE_FCNTL_PRAGMA:\n          const key = extractString(pArg, 4);\n          const value = extractString(pArg, 8);\n          this.log?.('xFileControl', file.path, 'PRAGMA', key, value);\n          switch (key.toLowerCase()) {\n            case 'journal_mode':\n              if (value &&\n                  !['off', 'memory', 'delete', 'wal'].includes(value.toLowerCase())) {\n                throw new Error('journal_mode must be \"off\", \"memory\", \"delete\", or \"wal\"');\n              }\n              break;\n          }\n          break;\n      }\n    } catch (e) {\n      this.lastError = e;\n      return VFS.SQLITE_IOERR;\n    }\n    return VFS.SQLITE_NOTFOUND;\n  }\n\n  /**\n   * @param {Uint8Array} zBuf \n   * @returns \n   */\n  jGetLastError(zBuf) {\n    if (this.lastError) {\n      console.error(this.lastError);\n      const outputArray = zBuf.subarray(0, zBuf.byteLength - 1);\n      const { written } = new TextEncoder().encodeInto(this.lastError.message, outputArray);\n      zBuf[written] = 0;\n    }\n    return VFS.SQLITE_OK\n  }\n\n  /**\n   * @param {FileSystemFileHandle} fileHandle \n   * @returns {Promise<PersistentFile>}\n   */\n  async #createPersistentFile(fileHandle) {\n    const persistentFile = new PersistentFile(fileHandle);\n    const root = await navigator.storage.getDirectory();\n    const relativePath = await root.resolve(fileHandle);\n    const path = `/${relativePath.join('/')}`;\n    persistentFile.handleRequestChannel = new BroadcastChannel(`ahp:${path}`);\n    this.persistentFiles.set(path, persistentFile);\n\n    const f = await fileHandle.getFile();\n    if (f.size) {\n      this.accessiblePaths.add(path);\n    }\n    return persistentFile;\n  }\n\n  /**\n   * @param {File} file \n   */\n  #requestAccessHandle(file) {\n    console.assert(!file.persistentFile.handleLockReleaser);\n    if (!file.persistentFile.isRequestInProgress) {\n      file.persistentFile.isRequestInProgress = true;\n      this._module.retryOps.push((async () => {\n        // Acquire the Web Lock.\n        file.persistentFile.handleLockReleaser = await this.#acquireLock(file.persistentFile);\n\n        // Get access handles for the database and releated files in parallel.\n        this.log?.(`creating access handles for ${file.path}`)\n        await Promise.all(DB_RELATED_FILE_SUFFIXES.map(async suffix => {\n          const persistentFile = this.persistentFiles.get(file.path + suffix);\n          if (persistentFile) {\n            persistentFile.accessHandle =\n              await persistentFile.fileHandle.createSyncAccessHandle();\n          }\n        }));\n        file.persistentFile.isRequestInProgress = false;\n      })());\n      return this._module.retryOps.at(-1);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * @param {File} file \n   */\n  async #releaseAccessHandle(file) {\n    DB_RELATED_FILE_SUFFIXES.forEach(async suffix => {\n      const persistentFile = this.persistentFiles.get(file.path + suffix);\n      if (persistentFile) {\n        persistentFile.accessHandle?.close();\n        persistentFile.accessHandle = null;\n      }\n    });\n    this.log?.(`access handles closed for ${file.path}`)\n\n    file.persistentFile.handleLockReleaser?.();\n    file.persistentFile.handleLockReleaser = null;\n    this.log?.(`lock released for ${file.path}`)\n  }\n\n  /**\n   * @param {PersistentFile} persistentFile \n   * @returns  {Promise<function>} lock releaser\n   */\n  #acquireLock(persistentFile) {\n    return new Promise(resolve => {\n      // Tell other connections we want the access handle.\n      const lockName = persistentFile.handleRequestChannel.name;\n      const notify = () => {\n        this.log?.(`notifying for ${lockName}`);\n        persistentFile.handleRequestChannel.postMessage(null);\n      }\n      const notifyId = setInterval(notify, LOCK_NOTIFY_INTERVAL);\n      setTimeout(notify);\n\n      this.log?.(`lock requested: ${lockName}`)\n      navigator.locks.request(lockName, lock => {\n        // We have the lock. Stop asking other connections for it.\n        this.log?.(`lock acquired: ${lockName}`, lock);\n        clearInterval(notifyId);\n        return new Promise(resolve);\n      });\n    });\n  }\n}\n\nfunction extractString(dataView, offset) {\n  const p = dataView.getUint32(offset, true);\n  if (p) {\n    const chars = new Uint8Array(dataView.buffer, p);\n    return new TextDecoder().decode(chars.subarray(0, chars.indexOf(0)));\n  }\n  return null;\n}"],"names":[],"sourceRoot":""}